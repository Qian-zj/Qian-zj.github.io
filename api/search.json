[{"id":"ff294b41f6454d72b979d968dd4769d6","title":"测试","content":"","slug":"测试","date":"2023-07-06T11:50:10.000Z","categories_index":"","tags_index":"","author_index":"阡净"},{"id":"33876cf3e210da358d8e4b065eea88e6","title":"axios","content":"Axios 是一个基于 promise 网络请求库，作用于node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。\n特性\n从浏览器创建 XMLHttpRequests\n从 node.js 创建 http 请求\n支持 Promise API\n拦截请求和响应\n转换请求和响应数据\n取消请求\n自动转换JSON数据\n客户端支持防御XSRF\n\n1、配置1.1、安装（三种方法）1）npm安装\n\n\n\n\n\n\n\n\nnpm install axios\n2）bower安装\n\n\n\n\n\n\n\n\nbower install axios\n3）通过cdn引入&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;axios&#x2F;1.3.6&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n\n\n2、用axios发送不同的4种请求方式前提\n运行json文件：终端输入npx json-server --watch db.json\n写axios请求前的初始代码：\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;axios&#x2F;1.3.6&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n        &lt;h2 class&#x3D;&quot;page-header&quot;&gt;基本使用&lt;&#x2F;h2&gt;\n        &lt;button class&#x3D;&quot;btn btn-primary&quot;&gt;发送GET请求&lt;&#x2F;button&gt;\n        &lt;button class&#x3D;&quot;btn btn-secondary&quot;&gt;发送POST请求&lt;&#x2F;button&gt;\n        &lt;button class&#x3D;&quot;btn btn-success&quot;&gt;发送PUT请求&lt;&#x2F;button&gt;\n        &lt;button class&#x3D;&quot;btn btn-danger&quot;&gt;发送DELETE请求&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n        &#x2F;&#x2F;获取按钮\n        const btns &#x3D; document.querySelectorAll(&#39;button&#39;)\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n2.1、发送GET请求&#x2F;&#x2F;第一个\n&#x2F;&#x2F;发送GET请求,获取数据\nbtns[0].onclick &#x3D; function()&#123;\n    &#x2F;&#x2F;发送axios请求\n    axios(&#123;\n        &#x2F;&#x2F;请求类型\n        method: &#39;GET&#39;,\n        &#x2F;&#x2F;URL\n        url:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;posts&#x2F;2&#39;\n    &#125;).then(response &#x3D;&gt; &#123;\n        console.log(response);\n    &#125;)\n&#125;\n\n\n\n2.2、发送POST请求\n\n\n\n\n\n\n\n\n发送成功后，db.json文件发生变化\n&#x2F;&#x2F;第二个\n&#x2F;&#x2F;发送POST请求，添加数据\nbtns[1].onclick &#x3D; function()&#123;\n    &#x2F;&#x2F;发送axios请求\n    axios(&#123;\n        &#x2F;&#x2F;请求类型\n        method: &#39;POST&#39;,\n        &#x2F;&#x2F;URL\n        url:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;posts&#39;,\n        &#x2F;&#x2F;设置请求体\n        data:&#123;\n            &quot;title&quot;: &quot;今天天气不错&quot;, \n            &quot;author&quot;: &quot;冷的要死&quot;\n        &#125;\n    &#125;).then(response &#x3D;&gt; &#123;\n        console.log(response);\n    &#125;)\n&#125;\n\n\n\n2.3、发送PUT请求&#x2F;&#x2F;第三个\n&#x2F;&#x2F;发送PUT请求，更新数据\nbtns[2].onclick &#x3D; function()&#123;\n    &#x2F;&#x2F;发送axios请求\n    axios(&#123;\n        &#x2F;&#x2F;请求类型\n        method: &#39;PUT&#39;,\n        &#x2F;&#x2F;URL\n        url:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;posts&#x2F;3&#39;,\n        &#x2F;&#x2F;设置请求体\n        data:&#123;\n            &quot;title&quot;: &quot;今天天气不错&quot;, \n            &quot;author&quot;: &quot;不对，是冷的要死&quot;\n        &#125;\n    &#125;).then(response &#x3D;&gt; &#123;\n    \tconsole.log(response);\n    &#125;)\n&#125;\n\n\n\n2.4、发送DELETE请求&#x2F;&#x2F;第四个按钮\n&#x2F;&#x2F;发送DELETE请求，更新数据\nbtns[3].onclick &#x3D; function()&#123;\n    &#x2F;&#x2F;发送axios请求\n    axios(&#123;\n        &#x2F;&#x2F;请求类型\n        method: &#39;DELETE&#39;,\n        &#x2F;&#x2F;URL\n        url:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;posts&#x2F;4&#39;\n    &#125;).then(response &#x3D;&gt; &#123;\n    \tconsole.log(response);\n    &#125;)\n&#125;\n\n\n\n3、axios其他的请求方法\n4、axios请求后，响应结果的结构控制台输出的response：\n├── config\n│   ├── method: 请求方式\n│   └── url: 请求地址\n├── data: 响应体(服务器的返回结果)\n├── headers: 响应头的信息\n├── request: 原生的AJAX请求对象\n│   ├── XMLHttpRequest实例对象\n├── status: 响应的状态码\n└── statusText: 响应的状态字符串\n\n\n\n├── node_modules \n├── public\n│   ├── favicon.ico: 页签图标\n│   └── index.html: 主页面\n├── src\n│   ├── assets: 存放静态资源\n│   │   └── logo.png\n│   │── component: 存放组件\n│   │   └── HelloWorld.vue\n│   │── App.vue: 汇总所有组件\n│   └── main.js: 入口文件\n├── .gitignore: git版本管制忽略的配置\n├── babel.config.js: babel的配置文件\n├── package.json: 应用包配置文件 \n├── README.md: 应用描述文件\n└── package-lock.json: 包版本控制文件\n\n\n\n5、axios配置对象高频常用参数罗列：\n\t1：url       &#x2F;&#x2F;  通过设置url参数，决定请求到底发送给谁\n\t2：method    &#x2F;&#x2F; 设置请求的类型，get&#x2F;post&#x2F;delete..\n\t3：baseURL   &#x2F;&#x2F; 设置url的基础结构，发送请求配置时只需要设置url即可，axios会自动将两者进行拼接\n\t4：headers   &#x2F;&#x2F; 头信息：比较实用的参数，在某些项目当中，进行身份校验的时候，要求在头信息中加入一个特殊的\t\t\t   标识  &#x2F;&#x2F; 来检验请求是否满足要求，可以借助headers对请求头信息做一个配置\n\t5：params    &#x2F;&#x2F; 也是一个比较常用的参数，来设定url参数的，可以通过params直接添加url参数名和参数值\n\t6：data\n\t7：timeout    &#x2F;&#x2F; 超时请求时间，单位是ms 超过请求时间，请求就会被取消\n\t8：其余的都是不经常使用的参数，了解即可！\n\n\n\n官方配置文档详解\n&#123;\n  &#x2F;&#x2F;  通过设置url参数，决定请求到底发送给谁\n  url: &#39;&#x2F;user&#39;,\n\n  &#x2F;&#x2F; 设置请求的类型，get&#x2F;post&#x2F;delete..\n  method: &#39;get&#39;, &#x2F;&#x2F; default\n\n  &#x2F;&#x2F; 设置url的基础结构，发送请求配置时只需要设置url即可，axios会自动将两者进行拼接\n  baseURL: &#39;https:&#x2F;&#x2F;some-domain.com&#x2F;api&#x2F;&#39;,\n\n  &#x2F;&#x2F; 可以对请求的数据做一个处理，在将处理完的结果向服务器发送\n  transformRequest: [function (data, headers) &#123;\n    &#x2F;&#x2F; Do whatever you want to transform the data\n    return data;\n  &#125;],\n\n  &#x2F;&#x2F; 对响应结果做一个处理配置\n  transformResponse: [function (data) &#123;\n    &#x2F;&#x2F; Do whatever you want to transform the data\n    return data;\n  &#125;],\n\n  &#x2F;&#x2F; 头信息：比较实用的参数，在某些项目当中，进行身份校验的时候，要求在头信息中加入一个特殊的标识\n  &#x2F;&#x2F; 来检验请求是否满足要求，可以借助headers对请求头信息做一个配置\n  headers: &#123;&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;&#125;,\n\n  &#x2F;&#x2F; 也是一个比较常用的参数，来设定url参数的，可以通过params直接添加url参数名和参数值\n  params: &#123;\n    ID: 12345\n  &#125;,\n\n  &#x2F;&#x2F; 参数序列化的，不经常使用，对请求的参数做一个系列化，转化成字符串\n  paramsSerializer: function (params) &#123;\n    return Qs.stringify(params, &#123;arrayFormat: &#39;brackets&#39;&#125;)\n  &#125;,\n\n  data: &#123;\n    firstName: &#39;Fred&#39;\n  &#125;,\n\n  data: &#39;Country&#x3D;Brasil&amp;City&#x3D;Belo Horizonte&#39;,\n\n  &#x2F;&#x2F; 超时请求时间，单位是ms 超过请求时间，请求就会被取消\n  timeout: 1000, &#x2F;&#x2F; default is &#96;0&#96; (no timeout)\n\n  &#x2F;&#x2F; 跨域请求时对cookie的携带做一个设置，false为不携带\n  withCredentials: false, &#x2F;&#x2F; default\n\n  &#x2F;&#x2F; 发送请求识别器做一个设置\n  adapter: function (config) &#123;\n    &#x2F;* ... *&#x2F;\n  &#125;,\n\n  &#x2F;&#x2F; 请求基础验证，设置用户名和密码的，相对用的较少\n  auth: &#123;\n    username: &#39;janedoe&#39;,\n    password: &#39;s00pers3cret&#39;\n  &#125;,\n\n  &#x2F;&#x2F; 对响应体结果的格式做个设置\n  responseType: &#39;json&#39;, &#x2F;&#x2F; default\n\n  responseEncoding: &#39;utf8&#39;, &#x2F;&#x2F; default\n  xsrfCookieName: &#39;XSRF-TOKEN&#39;, &#x2F;&#x2F; default\n  xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;, &#x2F;&#x2F; default\n  onUploadProgress: function (progressEvent) &#123;\n    &#x2F;&#x2F; Do whatever you want with the native progress event\n  &#125;,\n  onDownloadProgress: function (progressEvent) &#123;\n    &#x2F;&#x2F; Do whatever you want with the native progress event\n  &#125;,\n  maxContentLength: 2000,\n  maxBodyLength: 2000,\n  validateStatus: function (status) &#123;\n    return status &gt;&#x3D; 200 &amp;&amp; status &lt; 300; &#x2F;&#x2F; default\n  &#125;,\n  maxRedirects: 5, &#x2F;&#x2F; default\n  socketPath: null, &#x2F;&#x2F; default\n  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),\n  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),\n\n  proxy: &#123;\n    protocol: &#39;https&#39;,\n    host: &#39;127.0.0.1&#39;,\n    port: 9000,\n    auth: &#123;\n      username: &#39;mikeymike&#39;,\n      password: &#39;rapunz3l&#39;\n    &#125;\n  &#125;,\n\n  cancelToken: new CancelToken(function (cancel) &#123;\n  &#125;),\n  decompress: true &#x2F;&#x2F; default\n\n&#125;\n\n\n\n6、axios的默认配置&#x2F;&#x2F;获取按钮\nconst btns &#x3D; document.querySelectorAll(&#39;button&#39;)\n\n&#x2F;&#x2F;默认配置\naxios.defaults.method &#x3D; &#39;GET&#39;   &#x2F;&#x2F;设置默认的请求类型为GET\naxios.defaults.baseURL &#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#39;    &#x2F;&#x2F;设置基础URL\n\n&#x2F;&#x2F;获取数据\nbtns[0].onclick &#x3D; function()&#123;\n    axios(&#123;\n        &#x2F;&#x2F;URL\n        url:&#39;&#x2F;posts&#x2F;2&#39;\n    &#125;).then(response &#x3D;&gt; &#123;\n        console.log(response);\n    &#125;)\n&#125;\n\n\n\n7、创建实例对象发送请求&#x2F;&#x2F;获取按钮\nconst btns &#x3D; document.querySelectorAll(&#39;button&#39;)\n\n&#x2F;&#x2F;创建实例对象 http:&#x2F;&#x2F;localhost:3000&#x2F;posts\nconst arr &#x3D; axios.create ( &#123;\n    baseURL:&#39;http:&#x2F;&#x2F;localhost:3000&#39;,\n    timeout: 2000\n&#125;)\nconsole.log(arr);\n\n&#x2F;&#x2F;这里 arr 与 axios对象 的功能几乎是一样的\nbtns[0].onclick &#x3D; function()&#123;\n    &#x2F;&#x2F;和axios()方法一样\n    arr(&#123;\n        method:&#39;GET&#39;,\n        &#x2F;&#x2F;URL\n        url:&#39;&#x2F;posts&#x2F;2&#39;\n    &#125;).then(response &#x3D;&gt; &#123;\n    \tconsole.log(response);\n    &#125;)\n&#125;\n\n\n\n8、请求拦截器 和 响应拦截器\n\n\n\n\n\n\n\n\n执行顺序：\n\n单个请求拦截器 和 单个响应拦截器\n\n​    （顺序：请求开始 =&gt; 请求拦截器 =&gt; 响应拦截器 =&gt; 自定义回调）\n\n多个请求拦截器 和 多个响应拦截器（请求 按倒序执行，响应 按顺序执行）\n\n​    （顺序：请求开始 =&gt; 请求n =&gt; . . . =&gt; 请求1 =&gt; 响应1 =&gt; . . . =&gt; 响应n）\n&#x2F;&#x2F;第一步：设置请求拦截器\naxios.interceptors.request.use(  config &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 发生请求前的处理\n    console.log(&quot;请求拦截器，成功&quot;);\n    return config\n&#125;, err &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 请求错误处理\n    console.log(&#39;请求拦截器,失败&#39;);\n    return Promise.reject(err);\n&#125;)\n\n&#x2F;&#x2F;第二步：响应拦截器\naxios.interceptors.response.use(res&#x3D;&gt;&#123;\n    console.log(&#39;响应拦截器,成功&#39;);\n    &#x2F;&#x2F;请求成功对响应数据做处理\n    return res &#x2F;&#x2F;该返回对象会传到请求方法的响应对象中\n&#125;,err&#x3D;&gt;&#123;\n    console.log(&#39;响应拦截器,失败&#39;);\n    &#x2F;&#x2F; 响应错误处理\n    return Promise.reject(err);\n&#125;)\n\naxios(&#123;\n    method:&#39;GET&#39;,\n    &#x2F;&#x2F;URL\n    url:&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;posts&#x2F;2&#39;\n&#125;).then(response &#x3D;&gt; &#123;\n    &#x2F;&#x2F;第三步\n    console.log(&#39;自定义回调&#39;);\n    console.log(response);\n&#125;)\n\n","slug":"axios","date":"2023-05-09T06:55:19.000Z","categories_index":"Web 前端","tags_index":"axios","author_index":"阡净"},{"id":"b468f3c3ac71ea2b71e5a5059fe38476","title":"Promise","content":"Promise 是异步编程的一种解决方案：从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。promise有三种状态： **pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。\n1、执行js文件查看输出结果：\n\n\n\n\n\n\n\n\n终端输入 ：node 文件名\n1、Promise 的状态\n\n\n\n\n\n\n\n\nPromise 的状态：\n\n实例对象中的一个属性 【PromiseState】\npending ：未决定的\nresolved / fullfilled ：成功\nrejected ：失败\n\n\n\n\n\n\n\n\n\n\nPromise 的状态改变：\n\npending 变为 resolved\n\npending 变为 rejected\n\n\n  说明：      1. 只有这 2 种，且一个 promise 对象只能改变一次      2. 无论变为成功还是失败，都会有一个结果数据      3. 成功的结果数据一般称为 value，失败的结果数据一般称为 reason\n2、Promise 对象的值\n\n\n\n\n\n\n\n\nPromise 对象的值：\n\n实例对象中的一个属性 【PromiseResult】\n保存着异步任务【成功/失败】的结果\nresolved \nrejected \n\n3、Promise 的工作流程\n4、Promise 的API4.1、Promise 构造函数\n\n\n\n\n\n\n\n\nPromise 构造函数 ：Promise（executor）{}\n\nexcutor 函数：执行器（resolve，reject）=&gt; {}\nresolve 函数：内部定义成功时调用的函数 value =&gt; {}\nrejec 函数：内部定义失败时调用的函数 reason =&gt; {}\n\n&gt;说明：executor 会在 Promise 内部立即同步调用，在执行器中执行异步操作\n4.2、Promise.prototype.then 方法\n\n\n\n\n\n\n\n\nPromise.prototype.then 方法：(onResolved,onRejected) =&gt; {}\n\nonResolved 函数：成功的回调函数 （value） =&gt; {}\n\nonRejected 函数：失败的回调函数 （reason） =&gt; {}\n\n\n  注意：指定用于得到成功 value 的成功回调和用于失败 reason 的失败回调，返回一个新的 Promise 对象\n4.3、Promise.prototype.catch 方法\n\n\n\n\n\n\n\n\nPromise.prototype.catch 方法：(onRejected)  =&gt; {}\n\nonRejected 函数：失败的回调函数 （reasone）=&gt; {}\n\n&gt;注意：返回一个 promise 对象，并且处理拒绝的情况。它的行为与调用 Promise.prototype.then(undefined, onRejected) 相同\n4.4、Promise.resolve 方法\n\n\n\n\n\n\n\n\nPromise.resolve 方法 （value） =&gt; {}\n\nvalue：成功的数据或 promise 对象\n\n注意：返回一个成功&#x2F;失败（被解析过）的 promise 对象\n4.5、Promise.reject 方法\n\n\n\n\n\n\n\n\nPromise.resolve 方法 （value） =&gt; {}\n\nreason：失败的原因\n\n注意：返回一个失败的 promise 对象\n4.6、Promise.all 方法\n\n\n\n\n\n\n\n\nPromise.all 方法 (promises) =&gt; {}\n\npromises：包含n个 promise 的数组\n\n注意：返回一个新的 promise，只有所有的 promise 都成功才成功，只要有一个失败即为失败\n4.7、Promise.race 方法\n\n\n\n\n\n\n\n\nPromise.race 方法 (promises) =&gt; {}\n\npromises：包含n个 promise 的数组\n\n注意：返回一个新的 promise ，第一个改变的 promise 的结果的状态就是最终的结果状态\n5、Promise 的几个关键问题（重点）5.1、如何改变 promise 的状态？\n\n\n\n\n\n\n\n\n\nresolve(value)：如果当前是 pending 就会变为 resolved\nreject(reason)：如果当前是 pending 就会变为 rejected\nthrow &#39;xxx&#39; ：抛出异常，如果当前是 pending 就会变为rejected\n\n5.2、一个 promise 指定多个成功/失败回调函数都会调用吗？\n\n\n\n\n\n\n\n\n当 promise 改变为对应状态时都会调用\n5.3、改变 promise 状态和指定回调函数的先后顺序？\n\n\n\n\n\n\n\n\n（1）都有可能，正常情况下时先指定回调再改变状态，但也可以改变状态再指定回调\n\n\n\n\n\n\n\n\n\n（2）如何先改变状态，再指定回调？\n\n在执行器中直接调用 resolve() / reject()\n\n &gt;&#x2F;&#x2F;先改状态, 后指定回调函数\n&gt;new Promise((resolve, reject) &#x3D;&gt; &#123;\n resolve(1) &#x2F;&#x2F; 先改变的状态(同时指定数据)\n&gt;&#125;).then(&#x2F;&#x2F; 后指定回调函数, 异步执行回调函数\n value &#x3D;&gt; &#123;console.log(&#39;value2&#39;, value)&#125;,\n reason &#x3D;&gt; &#123;console.log(&#39;reason2&#39;, reason)&#125;\n&gt;)\n\n\n延迟更长时间才调用 then()：此时异步执行 \n\n &gt;&#x2F;&#x2F; 常规: 先指定回调函数, 后改变的状态\n&gt;new Promise((resolve, reject) &#x3D;&gt; &#123;\n setTimeout(() &#x3D;&gt; &#123;\n   resolve(1) &#x2F;&#x2F; 后改变的状态(同时指定数据), 异步执行回调函数\n &#125;, 1000);\n&gt;&#125;).then(&#x2F;&#x2F; 先指定回调函数, 保存当前指定的回调函数\n value &#x3D;&gt; &#123;&#125;,\n reason &#x3D;&gt; &#123;console.log(&#39;reason&#39;, reason)&#125;\n&gt;)\n\n\n\n\n\n\n\n\n\n（3）什么时候才能得到数据？\n\n如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据\n如果先改变状态，则当指定回调时，回调函数被调用，得到数据\n\n5.4、promise.then() 返回的新 promise 的结果状态由什么决定？\n\n\n\n\n\n\n\n\n1）简单表达：由 then（）指定的回调函数执行结果决定\n2）详细表达：\n\n如果抛出异常，新 promise 变为 rejected，reason为抛出的异常\n\n如果返回的是非 promise 的任意值，新 promise 变为 resolved ，value 为返回的值\n\n如果返回的是另一个新 promise，此 promise 的结果就会成为新 promise 的结果\n\n\n5.5、promise 中如何串联多个操作任务？\n\n\n\n\n\n\n\n\n（1）promise 的 then（）返回一个新的 promise ，可以变成 then（）的链式调用\n（2）通过 then（）的链式调用串联多个同步/异步任务\n5.6、promise 异常穿透？\n\n\n\n\n\n\n\n\n（1）当使用 promise 的 then（）链式调用时，可以在最后指定失败的回调\n（2）前面任何操作出了异常，都会传到最后失败的回调中处理\n5.7、如何中断 promise 链？【面试考点】\n\n\n\n\n\n\n\n\n（注意这里是中断而不是终止，因为 Promise 无法终止，这里的意思是：在合适的时候，把 pending 状态的 promise 给 reject 掉。）\n\n\n\n\n\n\n\n\n\n（1）当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数\n（2）办法: 在回调函数中返回一个 pendding 状态的 promise 对象\n&gt;【原因】：因为执行then中的成功还是失败的回调，是由上一个promise的状态决定的，如果中间返回一个初始状态的promise对象，then方法不知道执行哪一个回调，后面的then方法也不会执行，promisethen链会中断。\n6、async函数和await表达式6.1、async函数\n\n\n\n\n\n\n\n\n1、函数的返回值为 promise 对象\n2、promise 对象的结果由 async 函数执行的返回值决定\n（和 then 是一样的）\n6.2、await表达式\n\n\n\n\n\n\n\n\n1、await 右侧的表达式一般为 promise 对象，但也可以是其他的值\n2、如果表达式是 promise 对象，await返回的是 promise 成功的值\n3、如果表达式是其他值，直接将此值作为 await 的返回值\n\n\n\n\n\n\n\n\n\n注意：\n\nawait 必须写在 async 函数中，但 async 函数中可以没有await\n如果 await 的 promise 失败了，就会抛出异常，需要通过 try...catch 捕获处理\n\n","slug":"Promise","date":"2023-05-09T06:55:19.000Z","categories_index":"Web 前端","tags_index":"Promise","author_index":"阡净"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-05-09T06:02:28.531Z","categories_index":"","tags_index":"","author_index":"阡净"}]